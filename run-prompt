#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "click",
#     "mcp[cli]",
# ]
# ///

import os
import sys
import click
from pathlib import Path
import subprocess
from mcp.server.fastmcp import FastMCP

def find_prompt_file(prompt_name: str, script_dir: Path) -> Path | None:
    """Find the prompt file in various locations."""
    # Try different variations of the prompt file
    prompt_name_md = prompt_name if prompt_name.endswith('.md') else f"{prompt_name}.md"
    
    # Convert hyphenated names back to directory structure
    # e.g. 'code-lint' -> 'code/lint'
    prompt_path = prompt_name.replace('-', '/')
    prompt_path_md = prompt_path if prompt_path.endswith('.md') else f"{prompt_path}.md"
    
    # If prompt starts with directory name (e.g. code-lint), also try just the base name
    base_name = prompt_name.split('-')[-1]
    base_name_md = base_name if base_name.endswith('.md') else f"{base_name}.md"
    
    # Check in current directory
    if Path(prompt_name).exists():
        return Path(prompt_name)
    if Path(prompt_name_md).exists():
        return Path(prompt_name_md)
    
    # Check in script directory and its subdirectories
    search_dirs = [
        script_dir / "code",
        script_dir / "code" / "repomix",
        script_dir / "content",
        script_dir / "planning"
    ]
    
    # If prompt starts with a directory name (e.g. code-lint), prioritize that directory
    if '-' in prompt_name:
        dir_prefix = prompt_name.split('-')[0]
        if (script_dir / dir_prefix).exists():
            search_dirs.insert(0, script_dir / dir_prefix)
    
    for directory in search_dirs:
        if directory.exists():
            # Try both with and without .md extension
            if (directory / prompt_path).exists():
                return directory / prompt_path
            if (directory / prompt_path_md).exists():
                return directory / prompt_path_md
            # Try direct filename in this directory
            if (directory / prompt_name).exists():
                return directory / prompt_name
            if (directory / prompt_name_md).exists():
                return directory / prompt_name_md
            # Try with just the base name
            if (directory / base_name).exists():
                return directory / base_name
            if (directory / base_name_md).exists():
                return directory / base_name_md
    
    return None

def find_all_prompt_files(script_dir: Path) -> list[Path]:
    """Find all prompt files in the code, content, and planning directories."""
    prompt_files = []
    
    # Define directories to search
    search_dirs = [
        script_dir / "code",
        script_dir / "code" / "repomix",
        script_dir / "content",
        script_dir / "planning"
    ]
    
    # Search each directory for .md files that aren't README
    for directory in search_dirs:
        if directory.exists():
            for file in directory.glob("*.md"):
                if file.stem.lower() != "readme":
                    prompt_files.append(file)
    
    return prompt_files

def run_prompt(prompt_file: Path, input_text: str, model: str) -> int:
    """Run a prompt against input text and return the exit code."""
    with open(prompt_file) as f:
        prompt_content = f.read()
    
    cmd = ['llm', '-m', model, prompt_content]
    process = subprocess.Popen(cmd, stdin=subprocess.PIPE)
    process.communicate(input=input_text.encode())
    return process.returncode

@click.command()
@click.argument('prompt')
@click.argument('file', required=False, type=click.Path(exists=True))
def main(prompt: str, file: str | None):
    """Run a prompt against input from a file or stdin, or serve as an MCP endpoint."""
    # Get the directory where this script is located
    script_dir = Path(__file__).parent
    
    # Get MODEL from environment, default to claude-3.7-sonnet
    model = os.environ.get('MODEL', 'claude-3.7-sonnet')
    
    if prompt == "mcp":
        # Create MCP server in stdio mode
        mcp_server = FastMCP("prompt-library")
        
        # Add list-prompts command as a tool
        @mcp_server.tool(name="list-prompts", description="List all available prompts")
        def list_prompts() -> str:
            """List all available prompts."""
            prompt_files = find_all_prompt_files(script_dir)
            result = "Available prompts:\n\n"
            for prompt_file in prompt_files:
                prompt_name = str(prompt_file.relative_to(script_dir)).replace('/', '-').replace('.md', '')
                result += f"- {prompt_name}\n"
            return result
        
        # Add load-prompt command as a tool
        @mcp_server.tool(name="load-prompt", description="Load and return the contents of a specific prompt")
        def load_prompt(prompt_name: str) -> str:
            """Load and return the contents of a specific prompt."""
            prompt_file = find_prompt_file(prompt_name, script_dir)
            if not prompt_file:
                return f"Error: Unable to find prompt file: {prompt_name}"
            
            with open(prompt_file) as f:
                return f.read()

        # Add save-prompt command as a tool
        @mcp_server.tool(name="save-prompt", description="Save a new prompt file with the given title and body")
        def save_prompt(title: str, body: str) -> str:
            """Save a new prompt file with the given title and body."""
            # Validate title format
            if not title or not title.islower() or not all(c.isalnum() or c == '-' for c in title):
                return "Error: Title must be lowercase letters, numbers, and hyphens only"
            
            # Determine the directory based on the first part of the title
            parts = title.split('-')
            if len(parts) < 2:
                return "Error: Title must have at least two parts separated by hyphens (e.g., 'code-lint')"
            
            dir_name = parts[0]
            file_name = '-'.join(parts[1:]) + '.md'
            
            # Map directory names to valid directories
            valid_dirs = {
                'code': script_dir / 'code',
                'content': script_dir / 'content',
                'planning': script_dir / 'planning'
            }
            
            # Special case for repomix
            if len(parts) > 2 and parts[0] == 'code' and parts[1] == 'repomix':
                target_dir = script_dir / 'code' / 'repomix'
                file_name = '-'.join(parts[2:]) + '.md'
            elif dir_name not in valid_dirs:
                return f"Error: First part of title must be one of: {', '.join(valid_dirs.keys())}"
            else:
                target_dir = valid_dirs[dir_name]
            
            # Ensure target directory exists
            target_dir.mkdir(parents=True, exist_ok=True)
            
            # Create the file
            target_file = target_dir / file_name
            if target_file.exists():
                return f"Error: Prompt file already exists: {target_file}"
            
            with open(target_file, 'w') as f:
                f.write(body)
            
            return f"Successfully saved prompt to {target_file}"
        
        # Find all available prompt files and create prompt endpoints
        prompt_files = find_all_prompt_files(script_dir)
        for prompt_file in prompt_files:
            # Use relative path from script_dir as the prompt name
            prompt_name = str(prompt_file.relative_to(script_dir)).replace('/', '-').replace('.md', '')
            
            def create_prompt_handler(file_path):
                def get_prompt() -> str:
                    """Return the prompt content."""
                    with open(file_path) as f:
                        return f.read()
                return get_prompt
            
            mcp_server.prompt(name=prompt_name)(create_prompt_handler(prompt_file))
        
        # Run the server in stdio mode
        mcp_server.run(transport='stdio')
        return
    
    # Find the prompt file for regular mode
    prompt_file = find_prompt_file(prompt, script_dir)
    if not prompt_file:
        click.echo(f"Unable to find prompt file: {prompt} (also tried with .md extension)")
        sys.exit(1)
    
    # Regular CLI mode
    click.echo(f"[{model}] Running prompt: {prompt_file}")
    
    if file:
        with open(file) as f:
            input_text = f.read()
    else:
        input_text = sys.stdin.read()
    
    sys.exit(run_prompt(prompt_file, input_text, model))

if __name__ == '__main__':
    main() 