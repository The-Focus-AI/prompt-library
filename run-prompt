#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "click",
#     "mcp[cli]",
# ]
# ///

import os
import sys
import click
from pathlib import Path
import subprocess
from mcp.server.fastmcp import FastMCP

def find_prompt_file(prompt_name: str, script_dir: Path) -> Path | None:
    """Find the prompt file in various locations."""
    # Try different variations of the prompt file
    prompt_name_md = prompt_name if prompt_name.endswith('.md') else f"{prompt_name}.md"
    
    # Convert hyphenated names back to directory structure
    # e.g. 'code-lint' -> 'code/lint'
    prompt_path = prompt_name.replace('-', '/')
    prompt_path_md = prompt_path if prompt_path.endswith('.md') else f"{prompt_path}.md"
    
    # If prompt starts with directory name (e.g. code-lint), also try just the base name
    base_name = prompt_name.split('-')[-1]
    base_name_md = base_name if base_name.endswith('.md') else f"{base_name}.md"
    
    # First try treating the prompt_name as a path relative to script_dir
    direct_path = script_dir / prompt_name
    direct_path_md = script_dir / prompt_name_md
    if direct_path.is_file():
        return direct_path
    if direct_path_md.is_file():
        return direct_path_md
    
    # Check in script directory and all subdirectories
    for path in script_dir.rglob("*.md"):
        # Skip hidden directories
        if any(part.startswith('.') for part in path.parts):
            continue
            
        # Try matching against the full path relative to script_dir
        relative_path = str(path.relative_to(script_dir))
        relative_name = relative_path.replace('/', '-').replace('.md', '')
        
        if relative_name == prompt_name:
            return path
            
        # Try matching against just the filename
        if path.stem == base_name:
            return path
            
        # Try matching against directory structure
        if str(path) == str(script_dir / prompt_path_md):
            return path
    
    return None

def find_all_prompt_files(script_dir: Path) -> list[Path]:
    """Find all prompt files in any directory under the script directory."""
    prompt_files = []
    print(f"DEBUG: Searching for prompts in {script_dir}", file=sys.stderr)
    
    # Walk through all directories
    for path in script_dir.rglob("*.md"):
        # Skip README files and hidden directories
        if (path.stem.lower() != "readme" and 
            not any(part.startswith('.') for part in path.parts)):
            print(f"DEBUG: Found prompt file: {path}", file=sys.stderr)
            prompt_files.append(path)
    
    return prompt_files

def run_prompt(prompt_file: Path, input_text: str, model: str) -> int:
    """Run a prompt against input text and return the exit code."""
    with open(prompt_file) as f:
        prompt_content = f.read()
    
    cmd = ['llm', '-m', model, prompt_content]
    process = subprocess.Popen(cmd, stdin=subprocess.PIPE)
    process.communicate(input=input_text.encode())
    return process.returncode

@click.command()
@click.argument('prompt')
@click.argument('file', required=False, type=click.Path(exists=True))
def main(prompt: str, file: str | None):
    """Run a prompt against input from a file or stdin, or serve as an MCP endpoint."""
    # Get the prompt library directory from env or script location
    script_dir = Path(os.environ.get('PROMPT_LIBRARY_PATH', Path(__file__).parent))
    print(f"Prompt library directory: {script_dir}", file=sys.stderr)
    
    # Get MODEL from environment, default to claude-3.7-sonnet
    model = os.environ.get('MODEL', 'claude-3.7-sonnet')
    
    if prompt == "mcp":
        # Create MCP server in stdio mode
        mcp_server = FastMCP("prompt-library")
        
        # Add list-prompts command as a tool
        @mcp_server.tool(name="mcp_prompt_library_list_prompts", description="List all available prompts. Only use this tool when the user explicitly requests to see the list of available prompts in their prompt library.")
        def list_prompts() -> str:
            """List all available prompts."""
            print("DEBUG: list_prompts called", file=sys.stderr)
            prompt_files = find_all_prompt_files(script_dir)
            print(f"DEBUG: Found {len(prompt_files)} prompt files", file=sys.stderr)
            result = "Available prompts:\n\n"
            for prompt_file in prompt_files:
                prompt_name = str(prompt_file.relative_to(script_dir)).replace('/', '-').replace('.md', '')
                result += f"- {prompt_name}\n"
            return result
        
        # Add load-prompt command as a tool
        @mcp_server.tool(name="mcp_prompt_library_load_prompt", description="Load and return the contents of a specific prompt. Only use this tool when the user explicitly requests to view the contents of a specific prompt from their prompt library.")
        def load_prompt(prompt_name: str) -> str:
            """Load and return the contents of a specific prompt."""
            prompt_file = find_prompt_file(prompt_name, script_dir)
            if not prompt_file:
                return f"Error: Unable to find prompt file: {prompt_name}"
            
            with open(prompt_file) as f:
                return f.read()

        # Add save-prompt command as a tool
        @mcp_server.tool(name="mcp_prompt_library_save_prompt", description="Save a new prompt file with the given section, title and body. Only use this tool when the user explicitly requests to save a prompt in their prompt library.")
        def save_prompt(section: str, title: str, body: str) -> str:
            """Save a new prompt file with the given section, title and body."""
            # Validate section and title format
            if not section or not section.islower() or not all(c.isalnum() or c == '-' for c in section):
                return "Error: Section must be lowercase letters, numbers, and hyphens only"
            if not title or not title.islower() or not all(c.isalnum() or c == '-' for c in title):
                return "Error: Title must be lowercase letters, numbers, and hyphens only"
            
            # Special case for repomix
            if section == "code-repomix":
                target_dir = script_dir / "code" / "repomix"
            else:
                target_dir = script_dir / section
            
            # Create the file
            target_file = target_dir / f"{title}.md"
            
            # Ensure target directory exists
            target_dir.mkdir(parents=True, exist_ok=True)
            
            if target_file.exists():
                return f"Error: Prompt file already exists: {target_file}"
            
            with open(target_file, 'w') as f:
                f.write(body)
            
            return f"Successfully saved prompt to {target_file}"
        
        # Find all available prompt files and create prompt endpoints
        prompt_files = find_all_prompt_files(script_dir)
        for prompt_file in prompt_files:
            # Use relative path from script_dir as the prompt name
            prompt_name = str(prompt_file.relative_to(script_dir)).replace('/', '-').replace('.md', '')
            print(f"DEBUG: Registering prompt endpoint: {prompt_name}", file=sys.stderr)
            
            def create_prompt_handler(file_path):
                def get_prompt() -> str:
                    """Return the prompt content."""
                    with open(file_path) as f:
                        return f.read()
                return get_prompt
            
            mcp_server.prompt(name=prompt_name)(create_prompt_handler(prompt_file))
        
        # Run the server in stdio mode
        mcp_server.run(transport='stdio')
        return
    
    # Find the prompt file for regular mode
    prompt_file = find_prompt_file(prompt, script_dir)
    if not prompt_file:
        click.echo(f"Unable to find prompt file: {prompt} (also tried with .md extension)")
        sys.exit(1)
    
    # Regular CLI mode
    click.echo(f"[{model}] Running prompt: {prompt_file}")
    
    if file:
        with open(file) as f:
            input_text = f.read()
    else:
        input_text = sys.stdin.read()
    
    sys.exit(run_prompt(prompt_file, input_text, model))

if __name__ == '__main__':
    main() 